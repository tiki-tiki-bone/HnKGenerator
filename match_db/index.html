<!doctype html>
<html lang="ja">
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-NM6S92KNW1"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag() {
                dataLayer.push(arguments);
            }
            gtag("js", new Date());
            gtag("config", "G-NM6S92KNW1");
        </script>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>北斗の拳 対戦動画DB</title>
        <link rel="stylesheet" href="../css/match-cards.css" />
        <style>
            body {
                font-family: sans-serif;
                background-color: #f9f9f9;
                color: #333;
                margin: 0;
                padding: 0;
                overflow-x: hidden;
            }

            *,
            *::before,
            *::after {
                box-sizing: border-box;
            }

            header {
                background-color: #333;
                color: white;
                padding: 2rem 1rem 1rem;
                text-align: center;
                position: relative;
            }

            #navMenu {
                display: flex;
                justify-content: center;
                gap: 1rem;
                flex-wrap: nowrap;
            }

            #navMenu a {
                color: white;
                text-decoration: none;
                font-weight: 600;
                padding: 0.4rem 1rem;
                border: 2px solid transparent;
                border-radius: 4px;
                transition:
                    background-color 0.3s ease,
                    border-color 0.3s ease,
                    color 0.3s ease;
                font-size: 1rem;
                user-select: none;
            }

            #navMenu a:hover,
            #navMenu a:focus {
                background-color: #ffb347;
                color: #333;
                border-color: #ffb347;
                outline: none;
            }
            #toc a {
                text-decoration: none; /* 下線を消す */
                color: #333; /* 自然な文字色 */
                transition: color 0.2s; /* ホバー時に色変化 */
            }

            #toc a:hover {
                color: #0077cc; /* ホバーで少し目立たせる */
            }
            /* ハンバーガーボタン */
            .menu-toggle {
                display: none;
                position: absolute;
                top: 0.5rem;
                right: 0.5rem;
                width: 30px;
                height: 22px;
                cursor: pointer;
                flex-direction: column;
                justify-content: space-between;
                user-select: none;
                z-index: 10;
            }

            .menu-toggle span {
                display: block;
                height: 4px;
                background: white;
                border-radius: 2px;
            }

            /* スマホ用 */
            @media (max-width: 600px) {
                #navMenu {
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background-color: #333;
                    flex-direction: column;
                    display: none;
                    /* 初期は非表示 */
                    margin: 0;
                    padding: 0.5rem 0;
                }

                #navMenu a {
                    padding: 1rem;
                    border: none;
                    text-align: center;
                    font-size: 1.2rem;
                }

                #navMenu.show {
                    display: flex;
                }

                .menu-toggle {
                    display: flex;
                }

                h1 {
                    font-size: 18px;
                    margin-bottom: 10px;
                }
            }

            main {
                max-width: 900px;
                margin: 2rem auto;
                padding: 1rem;
                background: white;
                box-shadow: 0 0 8px rgba(0, 0, 0, 0.1);
                box-sizing: border-box;
            }

            h2 {
                border-bottom: 1px solid #ccc;
                padding-bottom: 0.5rem;
            }

            pre {
                background: #f0f0f0;
                padding: 1rem;
                overflow-x: auto;
            }

            .footer {
                text-align: center;
                color: #666;
                margin-top: 2rem;
                font-size: 0.9rem;
            }

            #annotation {
                position: fixed;
                bottom: 1rem;
                right: 1rem;
                background: #fff8dc;
                border: 1px solid #ccc;
                padding: 1rem 2rem 1rem 1rem;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
                z-index: 1000;
                font-size: 0.9rem;
                max-width: 300px;
                border-radius: 0.4rem;
            }

            #annotation-close {
                position: absolute;
                top: 4px;
                right: 8px;
                background: none;
                border: none;
                font-weight: bold;
                font-size: 1rem;
                cursor: pointer;
                color: #666;
            }

            /* ===== 対戦動画DB 検索 追加スタイル ===== */
            .panel {
                background: #f0f0f0;
                padding: 1rem;
                border-radius: 6px;
            }

            #searchPanel {
                --label-col: 9ch;
                --label-col-sub: 4ch;
            }

            .form-row {
                display: grid;
                grid-template-columns: var(--label-col, 9ch) minmax(0, 1fr);
                column-gap: 0.8rem;
                align-items: center;
                margin-bottom: 0.8rem;
            }

            .form-row.duo {
                display: grid;
                grid-template-columns:
                    var(--label-col, 9ch) minmax(0, 1fr) var(--label-col-sub, 4ch)
                    minmax(0, 0.6fr);
                align-items: center;
                column-gap: 0.9rem;
                row-gap: 0.6rem;
            }

            .form-row label {
                font-weight: 600;
                white-space: nowrap;
                justify-self: start;
            }

            .label-compact {
                min-width: auto;
                width: auto;
            }

            .label-short {
                display: none;
            }

            .form-row.duo label {
                min-width: auto;
            }

            .form-row input,
            .form-row select {
                padding: 0.5rem 0.6rem;
                border: 1px solid #ccc;
                border-radius: 6px;
                font-size: 1rem;
                min-width: 220px;
            }

            .suggest-field {
                position: relative;
                min-width: 220px;
            }

            .form-row > .suggest-field,
            .form-row > input,
            .form-row > .winner-switch {
                grid-column: 2;
                min-width: 220px;
            }

            .form-row > .winner-switch {
                min-width: 0;
                width: fit-content;
                justify-self: start;
            }

            .form-row:not(.duo) > select {
                grid-column: 2;
            }

            .form-row.duo > .suggest-field,
            .form-row.duo > select {
                min-width: 0;
            }

            .form-row.duo input {
                min-width: 0;
            }

            .form-row.duo > select {
                grid-column: 4;
            }

            .form-row.duo .suggest-field input,
            .form-row.duo select {
                width: 100%;
            }

            .winner-switch {
                display: inline-flex;
                flex-wrap: wrap;
                gap: 0;
                padding: 4px;
                border-radius: 4px;
                background: #e5e5ea;
                border: 1px solid #d1d1d6;
            }

            .winner-switch.is-disabled {
                opacity: 0.45;
            }

            .winner-switch.is-disabled .winner-option {
                cursor: default;
            }

            .winner-option {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                flex: 1 1 0;
                min-width: 0;
                border: none;
                background: transparent;
                color: #555;
                padding: 0.4rem 1.1rem;
                border-radius: 4px;
                font-weight: 600;
                cursor: pointer;
                min-width: 0;
                text-align: center;
                white-space: nowrap;
                transition:
                    background-color 0.2s ease,
                    color 0.2s ease,
                    box-shadow 0.2s ease;
            }

            .winner-option.active {
                background: #fff;
                color: #111;
                box-shadow: 0 2px 6px rgba(0, 0, 0, 0.18);
            }

            .winner-option:focus-visible {
                outline: 2px solid #2f2f2f;
                outline-offset: 2px;
            }

            .mode-switch input[type="radio"] {
                position: absolute;
                opacity: 0;
                pointer-events: none;
            }

            .mode-fields[hidden] {
                display: none;
            }

            .suggest-field input {
                width: 100%;
                padding-right: 2.2rem;
            }

            .suggestions {
                position: absolute;
                top: calc(100% + 4px);
                left: 0;
                right: 0;
                background: #fff;
                border: 1px solid #d6d6d6;
                border-radius: 6px;
                box-shadow: 0 8px 18px rgba(0, 0, 0, 0.08);
                max-height: 240px;
                overflow-y: auto;
                display: none;
                z-index: 20;
            }

            .suggestions.open {
                display: block;
            }

            .suggestion-item {
                padding: 0.5rem 0.7rem;
                cursor: pointer;
            }

            .suggestion-item:hover {
                background: #f3f3f3;
            }

            .suggest-field .clear-btn {
                position: absolute;
                right: 8px;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
                height: 20px;
                border: 1px solid #e5e5e5;
                border-radius: 4px;
                background: #fafafa;
                color: #666;
                font-size: 14px;
                line-height: 1;
                padding: 0;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
            }

            .suggest-field .clear-btn.is-hidden {
                display: none;
            }

            .suggest-field .clear-btn:hover {
                background: #f0f0f0;
            }

            .fixed-api {
                padding: 0.5rem 0.6rem;
                border: 1px solid #ccc;
                border-radius: 6px;
                font-size: 1rem;
                flex: 1;
                min-width: 220px;
                background: #fafafa;
                font-family:
                    ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
                    "Courier New", monospace;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .form-row .small {
                min-width: 120px;
                max-width: 180px;
                flex: 0 0 auto;
            }

            .radio-group {
                display: flex;
                gap: 1rem;
                flex-wrap: wrap;
            }

            .radio-group label {
                min-width: auto;
                font-weight: 500;
            }

            .actions {
                display: flex;
                gap: 0.6rem;
                flex-wrap: wrap;
                margin-top: 0.6rem;
            }

            .stats-links {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(0, 1fr));
                gap: 0.6rem;
            }

            .stats-links a {
                display: flex;
                font-size: calc(1rem - 1px);
                padding: 0.8rem 0.8rem;
                border: 1px solid var(--line);
                border-radius: 6px;
                background: #ffffff;
                color: inherit;
                text-decoration: none;
                text-align: center;
                align-items: center;
                justify-content: center;
                font-weight: 700;
            }

            .stats-links a:hover,
            .stats-links a:focus {
                border-color: #2d2d2d;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
                outline: none;
                color: inherit;
                text-decoration: none;
            }

            .stats-links a:visited {
                color: inherit;
                text-decoration: none;
            }

            #shareBtn {
                margin-left: auto;
            }

            button.primary {
                background-color: #333;
                color: white;
                border: none;
                padding: 0.55rem 1rem;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 700;
            }

            button.secondary {
                background-color: white;
                color: #333;
                border: 1px solid #aaa;
                padding: 0.55rem 1rem;
                border-radius: 6px;
                cursor: pointer;
                font-weight: 700;
            }

            .pager button.secondary {
                border-radius: 4px;
            }

            button.icon-button {
                padding: 0.45rem 0.65rem;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }

            button.icon-button svg {
                width: 18px;
                height: 18px;
                stroke: currentColor;
                fill: none;
                stroke-width: 2;
                stroke-linecap: round;
                stroke-linejoin: round;
            }

            button.primary:disabled,
            button.secondary:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .error {
                margin-top: 0.8rem;
                background: #fff0f0;
                border: 1px solid #ffb3b3;
                padding: 0.8rem;
                border-radius: 6px;
                color: #8a1f1f;
                display: none;
            }

            .table-wrap {
                overflow-x: auto;
            }

            .empty-state {
                padding: 1rem;
                border: 1px dashed var(--line);
                border-radius: 6px;
                color: var(--muted);
                text-align: center;
            }

            .video-cards {
                display: grid;
                gap: 0.9rem;
                width: 100%;
            }

            .video-card {
                background: #ffffff;
                border: 1px solid var(--line);
                border-radius: 8px;
                padding: 1rem;
                display: grid;
                grid-template-columns: 220px minmax(0, 1fr);
                gap: 0.6rem;
                align-items: start;
                background: #ffffff;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                transition:
                    border-color 0.18s ease,
                    box-shadow 0.18s ease,
                    transform 0.18s ease;
            }

            .video-card.is-clickable {
                cursor: pointer;
            }

            .video-card * {
                min-width: 0;
            }

            .video-thumb-wrap {
                grid-row: 1 / span 2;
            }

            .video-link {
                display: block;
                color: inherit;
                text-decoration: none;
            }

            .video-link:hover,
            .video-link:focus {
                text-decoration: underline;
            }

            .video-thumb {
                width: 100%;
                aspect-ratio: 16 / 9;
                object-fit: cover;
                border-radius: 6px;
                display: block;
                background: #e9e9e9;
            }

            .video-thumb.empty {
                display: none;
            }

            .video-title {
                font-size: 0.9rem;
                font-weight: 700;
                word-break: break-word;
            }

            .video-meta {
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 0.35rem;
                color: var(--muted);
                font-size: 0.85rem;
                min-width: 0;
            }

            .video-meta-item {
                display: flex;
                align-items: center;
                justify-content: flex-end;
                gap: 0.35rem;
                width: 100%;
            }

            .video-meta-item .label {
                color: var(--ink);
                font-weight: 600;
                text-align: right;
            }

            .video-meta-value {
                display: inline-flex;
                align-items: center;
                gap: 0.35rem;
                min-width: 0;
                justify-content: flex-end;
                text-align: right;
            }

            .video-meta-value span {
                min-width: 0;
            }

            .channel-icon {
                display: none;
            }

            .video-meta-link {
                display: inline-flex;
                align-items: center;
                gap: 0.35rem;
                color: inherit;
                text-decoration: none;
            }

            .video-meta-link:hover,
            .video-meta-link:focus {
                text-decoration: underline;
            }

            .video-card:hover,
            .video-card:focus-within {
                border-color: #2d2d2d;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08);
                outline: none;
                transform: translateY(-1px);
            }

            table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 0.5rem;
            }

            th,
            td {
                border-bottom: 1px solid #ddd;
                padding: 0.55rem 0.5rem;
                text-align: left;
                vertical-align: top;
                white-space: nowrap;
            }

            th {
                background: #f7f7f7;
                font-weight: 700;
            }

            td.wrap {
                white-space: normal;
            }

            .note {
                font-size: 0.95rem;
                color: #555;
            }

            @media (max-width: 600px) {
                .form-row,
                .form-row.duo {
                    display: flex;
                    flex-direction: column;
                    align-items: stretch;
                    gap: 0.35rem;
                }
                .form-row label {
                    font-size: 0.9rem;
                    min-width: 0;
                }
                .form-row.winner-row {
                    flex-direction: row;
                    align-items: center;
                }
                .label-full {
                    display: none;
                }
                .label-short {
                    display: inline;
                }
                .form-row input,
                .form-row select,
                .suggest-field {
                    min-width: 0;
                    width: 100%;
                }
                .radio-group {
                    width: 100%;
                }
                .actions {
                    flex-direction: column;
                    align-items: stretch;
                }
                .stats-links {
                    grid-template-columns: repeat(2, minmax(0, 1fr));
                }
                .stats-links a:last-child {
                    grid-column: 1 / -1;
                }
                .video-card {
                    grid-template-columns: 1fr;
                    padding: 0.8rem 0.9rem;
                }
                .video-title {
                    font-size: 1.05rem;
                }
                th,
                td {
                    font-size: 0.95rem;
                }
                .video-thumb-wrap {
                    grid-row: auto;
                }

                [data-mode-fields="card"] .form-row.duo {
                    display: grid;
                    grid-template-columns: 3ch minmax(0, 0.9fr) minmax(0, 0.7fr);
                    column-gap: 0.5rem;
                    row-gap: 0.35rem;
                    align-items: center;
                }

                [data-mode-fields="card"] .form-row.duo label {
                    font-size: 0.85rem;
                    white-space: nowrap;
                }

                [data-mode-fields="card"] .form-row.duo label[for="cardChar1"],
                [data-mode-fields="card"] .form-row.duo label[for="cardChar2"] {
                    display: none;
                }

                [data-mode-fields="card"] .form-row.duo > .suggest-field,
                [data-mode-fields="card"] .form-row.duo > select {
                    min-width: 0;
                    width: 100%;
                }

                [data-mode-fields="card"] .form-row.duo > select {
                    grid-column: 3;
                }
            }

            /* ====== clean fightlog ====== */
            :root {
                --ink: #222;
                --muted: #6b6b6b;
                --line: #d6d6d6;
                --card: #ffffff;
                --surface: #f7f7f7;
                --accent: #ffb347;
                --p1: #c64b4b;
                --p2: #2f6edc;
            }

            body {
                color: var(--ink);
                background-color: #f3f3f3;
            }

            main {
                background: var(--card);
                border: 1px solid var(--line);
                border-radius: 8px;
                box-shadow: 0 10px 20px rgba(0, 0, 0, 0.08);
                box-sizing: border-box;
            }

            section {
                margin-bottom: 1.6rem;
            }

            .section-meta {
                color: var(--muted);
                font-size: 0.85rem;
                letter-spacing: 0.02em;
                background: var(--surface);
                border-radius: 4px;
                padding: 0.15rem 0.4rem;
            }

            .result-title-wrap {
                display: inline-flex;
                align-items: center;
                gap: 0.6rem;
                flex-wrap: wrap;
            }

            .result-action {
                white-space: nowrap;
            }

            button.secondary.small {
                padding: 0.35rem 0.75rem;
                font-size: 0.9rem;
            }

            h2 {
                border: none;
                background: var(--surface);
                padding: 0.45rem 0.8rem;
                border-left: 6px solid var(--accent);
                border-radius: 6px;
                font-size: 1.05rem;
                display: flex;
                align-items: center;
                justify-content: space-between;
                gap: 0.8rem;
            }

            .panel {
                background: var(--card);
                border: 1px solid var(--line);
                border-radius: 8px;
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.06);
            }

            .form-row label {
                color: var(--muted);
                font-size: 0.85rem;
                letter-spacing: 0.03em;
            }

            .form-row input,
            .form-row select,
            .form-row textarea {
                border: 1px solid #cfd3da;
                border-radius: 6px;
                background: #ffffff;
                box-shadow: none;
            }

            button.primary {
                background-color: #2f2f2f;
                color: #ffffff;
                border: 1px solid #1d1d1d;
            }

            button.secondary {
                background-color: #ffffff;
                border: 1px solid #b9b9b9;
            }

            .status {
                background: #f8f4ea;
                border: 1px solid #e4d1a6;
                border-radius: 6px;
                padding: 0.4rem 0.6rem;
                display: inline-block;
            }

            table {
                border-collapse: collapse;
                border-spacing: 0;
            }

            thead th {
                background: #2f2f2f;
                color: #ffffff;
                font-size: 0.85rem;
                letter-spacing: 0.04em;
                border: none;
            }

            tbody td {
                background: #ffffff;
                border-bottom: 1px solid var(--line);
            }

            tbody tr:nth-child(even) td {
                background: #fafafa;
            }

            main a {
                color: #1f4d99;
                text-decoration: none;
            }

            main a:hover,
            main a:focus {
                color: #0f244d;
                text-decoration: underline;
            }

            .db-about-link {
                text-align: right;
                margin-bottom: 0.6rem;
                font-size: 0.9rem;
            }

            .db-about-link a {
                display: inline-flex;
                align-items: center;
                gap: 0.1rem;
            }

            .db-about-icon {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                width: 1.1em;
                height: 1.1em;
                border: 1.5px solid currentColor;
                border-radius: 50%;
                font-size: 0.85em;
                font-weight: 700;
                line-height: 1;
                margin-right: 0.1em;
            }
        
            </style>
        <script src="../js/site-header.js" defer data-site-header></script>
    </head>

    <body>
        <div id="siteHeader" data-title="北斗の拳 対戦動画DB"></div>

        <main>
            <div class="db-about-link">
                <a href="about/">
                    <span class="db-about-icon" aria-hidden="true">i</span>
                    対戦動画DBについて
                </a>
            </div>
            <section id="statsSection">
                <h2>統計</h2>
                <div class="panel">
                    <div class="stats-links">
                        <a href="diagram/">対戦ダイアグラム</a>
                        <a href="diagram_upper/">対戦ダイアグラム<br />（上位勢）</a>
                        <a href="character_usage/">キャラ使用率<br />ランキング</a>
                        <a href="character_usage_upper/"
                            >キャラ使用率<br />ランキング<br />（上位勢）</a
                        >
                        <a href="rankings/">勝率ランキング</a>
                    </div>
                </div>
            </section>

            <section>
                <h2>検索</h2>
                <div class="panel" id="searchPanel">
                    <div class="form-row">
                        <label>検索モード</label>
                        <div id="modeSwitch" class="winner-switch mode-switch" role="tablist">
                            <button type="button" class="winner-option active" data-mode="player">
                                プレイヤー検索
                            </button>
                            <button type="button" class="winner-option" data-mode="card">
                                対戦カード
                            </button>
                            <button type="button" class="winner-option" data-mode="video">
                                動画検索
                            </button>
                        </div>
                    </div>

                    <div class="mode-fields" data-mode-fields="player">
                        <div class="form-row duo">
                            <label for="playerInput" class="label-compact">プレイヤー</label>
                            <div class="suggest-field">
                                <input
                                    id="playerInput"
                                    type="text"
                                    placeholder="プレイヤー名"
                                    autocomplete="off"
                                />
                                <input id="playerId" type="hidden" />
                                <button
                                    type="button"
                                    class="clear-btn is-hidden"
                                    aria-label="プレイヤー入力をクリア"
                                >
                                    &times;
                                </button>
                                <div id="playerSuggestions" class="suggestions"></div>
                            </div>
                            <label for="playerChar">キャラ</label>
                            <select id="playerChar"></select>
                        </div>

                        <div class="form-row winner-row">
                            <label>勝敗</label>
                            <div class="winner-switch" data-winner-group="player">
                                <button type="button" class="winner-option active" data-w="all">
                                    すべて
                                </button>
                                <button type="button" class="winner-option" data-w="p1">
                                    勝ち
                                </button>
                                <button type="button" class="winner-option" data-w="p2">
                                    負け
                                </button>
                            </div>
                        </div>

                        <div class="form-row">
                            <label for="playerVideo">動画ID/URL</label>
                            <div class="suggest-field">
                                <input
                                    id="playerVideo"
                                    type="text"
                                    placeholder="動画ID / URL"
                                    autocomplete="off"
                                />
                                <button
                                    type="button"
                                    class="clear-btn is-hidden"
                                    aria-label="動画ID入力をクリア"
                                >
                                    &times;
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="mode-fields" data-mode-fields="card" hidden>
                        <div class="form-row duo">
                            <label for="cardPlayer1">
                                <span class="label-full">プレイヤー1</span>
                                <span class="label-short">P1</span>
                            </label>
                            <div class="suggest-field">
                                <input
                                    id="cardPlayer1"
                                    type="text"
                                    placeholder="プレイヤー名"
                                    autocomplete="off"
                                />
                                <input id="cardPlayer1Id" type="hidden" />
                                <button
                                    type="button"
                                    class="clear-btn is-hidden"
                                    aria-label="プレイヤー1入力をクリア"
                                >
                                    &times;
                                </button>
                                <div id="cardPlayer1Suggestions" class="suggestions"></div>
                            </div>
                            <label for="cardChar1">キャラ</label>
                            <select id="cardChar1"></select>
                        </div>

                        <div class="form-row duo">
                            <label for="cardPlayer2">
                                <span class="label-full">プレイヤー2</span>
                                <span class="label-short">P2</span>
                            </label>
                            <div class="suggest-field">
                                <input
                                    id="cardPlayer2"
                                    type="text"
                                    placeholder="プレイヤー名"
                                    autocomplete="off"
                                />
                                <input id="cardPlayer2Id" type="hidden" />
                                <button
                                    type="button"
                                    class="clear-btn is-hidden"
                                    aria-label="プレイヤー2入力をクリア"
                                >
                                    &times;
                                </button>
                                <div id="cardPlayer2Suggestions" class="suggestions"></div>
                            </div>
                            <label for="cardChar2">キャラ</label>
                            <select id="cardChar2"></select>
                        </div>

                        <div class="form-row winner-row">
                            <label>勝者</label>
                            <div class="winner-switch" data-winner-group="card">
                                <button type="button" class="winner-option active" data-w="all">
                                    すべて
                                </button>
                                <button type="button" class="winner-option" data-w="p1">P1</button>
                                <button type="button" class="winner-option" data-w="p2">P2</button>
                            </div>
                        </div>

                        <div class="form-row">
                            <label for="cardVideo">動画ID/URL</label>
                            <div class="suggest-field">
                                <input
                                    id="cardVideo"
                                    type="text"
                                    placeholder="動画ID / URL"
                                    autocomplete="off"
                                />
                                <button
                                    type="button"
                                    class="clear-btn is-hidden"
                                    aria-label="動画ID入力をクリア"
                                >
                                    &times;
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="mode-fields" data-mode-fields="video" hidden>
                        <div class="form-row">
                            <label for="videoQuery">検索</label>
                            <div class="suggest-field">
                                <input
                                    id="videoQuery"
                                    type="text"
                                    placeholder="動画ID / タイトル / チャンネル名"
                                    autocomplete="off"
                                />
                                <button
                                    type="button"
                                    class="clear-btn is-hidden"
                                    aria-label="検索入力をクリア"
                                >
                                    &times;
                                </button>
                            </div>
                        </div>

                        <div class="form-row">
                            <label for="locate">場所</label>
                            <select id="locate">
                                <option value="">すべて</option>
                            </select>
                        </div>
                    </div>

                    <div class="actions">
                        <button id="searchBtn" class="primary" type="button">検索</button>
                        <button
                            id="shareBtn"
                            class="secondary icon-button"
                            type="button"
                            aria-label="共有URL"
                            title="共有URL"
                        >
                            <svg viewBox="0 0 24 24" aria-hidden="true">
                                <circle cx="18" cy="5" r="2"></circle>
                                <circle cx="6" cy="12" r="2"></circle>
                                <circle cx="18" cy="19" r="2"></circle>
                                <line x1="8" y1="12" x2="16" y2="7"></line>
                                <line x1="8" y1="12" x2="16" y2="17"></line>
                            </svg>
                        </button>
                    </div>

                    <div id="error" class="error"></div>
                </div>
            </section>
            <section>
                <h2>
                    <span class="result-title-wrap">
                        <span id="resultTitle">動画一覧</span>
                        <span id="resultCount" class="section-meta"></span>
                    </span>
                    <button
                        id="playSeqBtn"
                        class="secondary small result-action"
                        type="button"
                        hidden
                    >
                        連続再生
                    </button>
                </h2>
                <div class="pager pager-top">
                    <button id="prevBtnTop" class="secondary" type="button">前へ</button>
                    <div id="pagerPagesTop" class="pager-pages" aria-label="ページ"></div>
                    <button id="nextBtnTop" class="secondary" type="button">次へ</button>
                </div>
                <div id="matchBody" class="match-cards" role="list"></div>
                <div id="videoBody" class="video-cards" role="list" hidden></div>

                <div class="pager">
                    <button id="prevBtn" class="secondary" type="button">前へ</button>
                    <div id="pagerPages" class="pager-pages" aria-label="ページ"></div>
                    <button id="nextBtn" class="secondary" type="button">次へ</button>
                </div>
            </section>

            <script src="../js/match-cards.js"></script>
            <script src="../js/api-config.local.js"></script>
            <script>
                const API_BASE = window.API_BASE || "https://hnk-match-db-api.tikibone.workers.dev";
                const IMAGE_BASE = "../images/";
                const MODE = {
                    PLAYER: "player",
                    CARD: "card",
                    VIDEO: "video",
                };
                const DEFAULTS = {
                    mode: MODE.PLAYER,
                    limit: 20,
                    page: 1,
                };
                const DB_ERROR_MSG =
                    "\u0044\u0042\u3078\u306e\u554f\u3044\u5408\u308f\u305b\u306b\u5931\u6557\u3057\u307e\u3057\u305f\u3002\u7ba1\u7406\u8005\u306b\u304a\u554f\u3044\u5408\u308f\u305b\u304f\u3060\u3055\u3044\u3002";
                const DATE_PREFIX = "\u6295\u7a3f\u65e5\uFF1A";

                const errorEl = document.getElementById("error");
                const resultTitleEl = document.getElementById("resultTitle");
                const resultCountEl = document.getElementById("resultCount");
                const playSeqBtn = document.getElementById("playSeqBtn");
                const statsSectionEl = document.getElementById("statsSection");
                const searchPanelEl = document.getElementById("searchPanel");
                const matchBody = document.getElementById("matchBody");
                const videoBody = document.getElementById("videoBody");

                const modeButtons = Array.from(document.querySelectorAll("[data-mode]"));
                const modeFields = Array.from(document.querySelectorAll("[data-mode-fields]"));

                const playerInput = document.getElementById("playerInput");
                const playerIdEl = document.getElementById("playerId");
                const playerSuggestions = document.getElementById("playerSuggestions");
                const playerCharEl = document.getElementById("playerChar");
                const playerVideoEl = document.getElementById("playerVideo");

                const cardPlayer1Input = document.getElementById("cardPlayer1");
                const cardPlayer1IdEl = document.getElementById("cardPlayer1Id");
                const cardPlayer1Suggestions = document.getElementById("cardPlayer1Suggestions");
                const cardChar1El = document.getElementById("cardChar1");

                const cardPlayer2Input = document.getElementById("cardPlayer2");
                const cardPlayer2IdEl = document.getElementById("cardPlayer2Id");
                const cardPlayer2Suggestions = document.getElementById("cardPlayer2Suggestions");
                const cardChar2El = document.getElementById("cardChar2");

                const cardVideoEl = document.getElementById("cardVideo");

                const videoQueryEl = document.getElementById("videoQuery");
                const locateEl = document.getElementById("locate");

                const searchBtn = document.getElementById("searchBtn");
                const shareBtn = document.getElementById("shareBtn");

                const prevBtn = document.getElementById("prevBtn");
                const nextBtn = document.getElementById("nextBtn");
                const prevBtnTop = document.getElementById("prevBtnTop");
                const nextBtnTop = document.getElementById("nextBtnTop");
                const pagerPagesEl = document.getElementById("pagerPages");
                const pagerPagesTopEl = document.getElementById("pagerPagesTop");

                let currentMode = DEFAULTS.mode;
                let lastPage = DEFAULTS.page;
                let lastPageSize = DEFAULTS.limit;
                let lastHasNext = null;
                let lastTotal = 0;
                let lastListMode = MODE.VIDEO;
                let lastMatchItems = [];

                const videoInfoCache = new Map();
                const videoInfoPending = new Set();
                function setError(msg) {
                    if (!errorEl) return;
                    if (!msg) {
                        errorEl.style.display = "none";
                        errorEl.textContent = "";
                        return;
                    }
                    errorEl.style.display = "block";
                    errorEl.textContent = msg;
                }

                function clampInt(raw, min, max, fallback) {
                    const n = parseInt(raw, 10);
                    if (!Number.isFinite(n)) return fallback;
                    return Math.max(min, Math.min(max, n));
                }

                function extractVideoId(raw) {
                    const value = String(raw || "").trim();
                    if (!value) return "";
                    try {
                        const url = new URL(value);
                        const host = url.hostname.replace(/^www\./, "");
                        if (host === "youtu.be") {
                            return url.pathname.replace(/^\/+/, "").split(/[?#/]/)[0] || "";
                        }
                        if (host.endsWith("youtube.com") || host.endsWith("youtube-nocookie.com")) {
                            const v = url.searchParams.get("v");
                            if (v) return v;
                            const parts = url.pathname.split("/").filter(Boolean);
                            if (
                                parts[0] === "shorts" ||
                                parts[0] === "embed" ||
                                parts[0] === "live"
                            ) {
                                return parts[1] || "";
                            }
                        }
                    } catch {
                        // fall through
                    }
                    const match = value.match(/[?&]v=([^&]+)/);
                    if (match) return match[1];
                    const shortMatch = value.match(/youtu\.be\/([^?&/]+)/);
                    if (shortMatch) return shortMatch[1];
                    return value;
                }

                function normalizeVideoQuery(raw) {
                    const value = String(raw || "").trim();
                    if (!value) return "";
                    return extractVideoId(value) || value;
                }

                function toHiragana(value) {
                    return String(value || "").replace(/[\u30a1-\u30f6]/g, (ch) =>
                        String.fromCharCode(ch.charCodeAt(0) - 0x60),
                    );
                }

                function toKatakana(value) {
                    return String(value || "").replace(/[\u3041-\u3096]/g, (ch) =>
                        String.fromCharCode(ch.charCodeAt(0) + 0x60),
                    );
                }

                function normalizeKana(value) {
                    return toHiragana(value).toLowerCase();
                }

                function fetchPlayerSuggestions(query, limit = 20) {
                    const raw = String(query || "").trim();
                    if (!raw) return Promise.resolve([]);
                    const queries = Array.from(new Set([raw, toHiragana(raw), toKatakana(raw)]));
                    return Promise.all(
                        queries.map(async (q) => {
                            try {
                                const url = `${API_BASE}/api/players?q=${encodeURIComponent(q)}&limit=${limit}`;
                                const res = await fetch(url);
                                if (!res.ok) return [];
                                const data = await res.json();
                                return Array.isArray(data.items) ? data.items : [];
                            } catch {
                                return [];
                            }
                        }),
                    ).then((groups) => {
                        const merged = [];
                        const seen = new Set();
                        for (const group of groups) {
                            for (const item of group) {
                                const id = String(item.player_id ?? "").trim();
                                const key = id || JSON.stringify(item);
                                if (!key || seen.has(key)) continue;
                                seen.add(key);
                                merged.push(item);
                            }
                        }
                        return merged;
                    });
                }

                function toggleClearButton(inputEl) {
                    if (!inputEl) return;
                    const field = inputEl.closest(".suggest-field");
                    if (!field) return;
                    const btn = field.querySelector(".clear-btn");
                    if (!btn) return;
                    const hasValue = Boolean(String(inputEl.value || "").trim());
                    btn.classList.toggle("is-hidden", !hasValue);
                }

                function refreshClearButtons() {
                    [
                        playerInput,
                        cardPlayer1Input,
                        cardPlayer2Input,
                        playerVideoEl,
                        cardVideoEl,
                        videoQueryEl,
                    ].forEach((input) => toggleClearButton(input));
                }

                function attachClearButton(inputEl, onClear) {
                    if (!inputEl) return;
                    const field = inputEl.closest(".suggest-field");
                    if (!field) return;
                    const btn = field.querySelector(".clear-btn");
                    if (!btn) return;
                    btn.addEventListener("click", (e) => {
                        e.preventDefault();
                        inputEl.value = "";
                        if (typeof onClear === "function") onClear();
                        inputEl.dispatchEvent(new Event("input", { bubbles: true }));
                    });
                    inputEl.addEventListener("input", () => toggleClearButton(inputEl));
                    toggleClearButton(inputEl);
                }

                function setWinnerValue(container, value) {
                    if (!container) return;
                    const buttons = Array.from(container.querySelectorAll(".winner-option"));
                    const candidate = value || "all";
                    const hasCandidate = buttons.some((btn) => btn.dataset.w === candidate);
                    const next = hasCandidate ? candidate : "all";
                    container.dataset.value = next;
                    buttons.forEach((btn) => {
                        btn.classList.toggle("active", btn.dataset.w === next);
                    });
                }

                function getWinnerValue(container) {
                    if (!container) return "all";
                    return container.dataset.value || "all";
                }

                function readPlayerId(inputEl, hiddenEl) {
                    const hidden = hiddenEl ? String(hiddenEl.value || "").trim() : "";
                    if (hidden) return hidden;
                    const raw = inputEl ? String(inputEl.value || "").trim() : "";
                    if (/^\d+$/.test(raw)) return raw;
                    return "";
                }

                function isNumericId(value) {
                    return /^\d+$/.test(String(value || "").trim());
                }

                function hasUnresolvedPlayer(inputEl, hiddenEl) {
                    const raw = String(inputEl?.value || "").trim();
                    if (!raw) return false;
                    if (isNumericId(raw)) return false;
                    const id = String(hiddenEl?.value || "").trim();
                    return !id;
                }

                async function resolvePlayerIdFromInput(inputEl, hiddenEl) {
                    if (!inputEl) return "";
                    const currentHidden = hiddenEl ? String(hiddenEl.value || "").trim() : "";
                    if (currentHidden) return currentHidden;
                    const raw = String(inputEl.value || "").trim();
                    if (!raw) return "";
                    if (isNumericId(raw)) return raw;
                    try {
                        const items = await fetchPlayerSuggestions(raw, 20);
                        const lower = raw.toLowerCase();
                        const kana = normalizeKana(raw);
                        const exact =
                            items.find((it) => String(it.player_id) === raw) ||
                            items.find(
                                (it) =>
                                    String(it.canonical_name || "").toLowerCase() === lower ||
                                    String(it.display_name || "").toLowerCase() === lower ||
                                    normalizeKana(it.canonical_name || "") === kana ||
                                    normalizeKana(it.display_name || "") === kana,
                            );
                        if (!exact) return "";
                        const id = String(exact.player_id || "").trim();
                        if (id && hiddenEl) hiddenEl.value = id;
                        return id;
                    } catch {
                        return "";
                    }
                }

                function setMode(nextMode) {
                    const mode = Object.values(MODE).includes(nextMode) ? nextMode : DEFAULTS.mode;
                    currentMode = mode;
                    modeButtons.forEach((btn) => {
                        btn.classList.toggle("active", btn.dataset.mode === mode);
                    });
                    modeFields.forEach((group) => {
                        group.hidden = group.dataset.modeFields !== mode;
                    });
                    syncLabelColumns();
                }

                function getListMode(state) {
                    if (!state) return currentMode;
                    const mode = state.mode;
                    const hasInput = hasSearchInputs(mode);
                    if (isDefaultState(state) && !hasInput && mode === MODE.PLAYER) {
                        return MODE.VIDEO;
                    }
                    return mode;
                }

                function syncResultBodies(listMode) {
                    const isVideo = listMode === MODE.VIDEO;
                    lastListMode = listMode;
                    if (matchBody) {
                        matchBody.hidden = isVideo;
                        matchBody.style.display = isVideo ? "none" : "";
                    }
                    if (videoBody) {
                        videoBody.hidden = !isVideo;
                        videoBody.style.display = isVideo ? "" : "none";
                    }
                }

                function syncLabelColumns() {
                    if (!searchPanelEl) return;
                    let main = 0;
                    let sub = 0;
                    const rows = searchPanelEl.querySelectorAll(".form-row");
                    rows.forEach((row) => {
                        if (row.offsetParent === null) return;
                        if (row.classList.contains("duo")) {
                            const labels = row.querySelectorAll(":scope > label");
                            if (labels[0]) {
                                main = Math.max(main, labels[0].getBoundingClientRect().width);
                            }
                            if (labels[1]) {
                                sub = Math.max(sub, labels[1].getBoundingClientRect().width);
                            }
                        } else {
                            const label = row.querySelector(":scope > label");
                            if (label) {
                                main = Math.max(main, label.getBoundingClientRect().width);
                            }
                        }
                    });
                    if (main > 0) {
                        searchPanelEl.style.setProperty("--label-col", `${Math.ceil(main)}px`);
                    }
                    if (sub > 0) {
                        searchPanelEl.style.setProperty("--label-col-sub", `${Math.ceil(sub)}px`);
                    }
                }

                function isDefaultState(state) {
                    if (!state) return true;
                    if (state.mode === MODE.VIDEO) {
                        return !state.q && !state.locate_id;
                    }
                    if (state.mode === MODE.CARD) {
                        return !state.p1 && !state.p2 && !state.ch1 && !state.ch2 && !state.vid;
                    }
                    return !state.p && !state.ch && !state.vid;
                }

                function hasSearchInputs(mode) {
                    const playerWinner = document.querySelector('[data-winner-group="player"]');
                    const cardWinner = document.querySelector('[data-winner-group="card"]');
                    if (mode === MODE.VIDEO) {
                        return (
                            Boolean(videoQueryEl && videoQueryEl.value.trim()) ||
                            Boolean(locateEl && locateEl.value)
                        );
                    }
                    if (mode === MODE.CARD) {
                        return (
                            Boolean(cardPlayer1Input && cardPlayer1Input.value.trim()) ||
                            Boolean(cardPlayer2Input && cardPlayer2Input.value.trim()) ||
                            Boolean(cardChar1El && cardChar1El.value) ||
                            Boolean(cardChar2El && cardChar2El.value) ||
                            Boolean(cardVideoEl && cardVideoEl.value.trim()) ||
                            getWinnerValue(cardWinner) !== "all"
                        );
                    }
                    return (
                        Boolean(playerInput && playerInput.value.trim()) ||
                        Boolean(playerCharEl && playerCharEl.value) ||
                        Boolean(playerVideoEl && playerVideoEl.value.trim()) ||
                        getWinnerValue(playerWinner) !== "all"
                    );
                }

                function updateResultTitle(state) {
                    if (!resultTitleEl || !state) return;
                    const hasInput = hasSearchInputs(state.mode);
                    const isDefault = isDefaultState(state) && !hasInput;
                    const listMode = getListMode(state);
                    if (listMode === MODE.VIDEO) {
                        resultTitleEl.textContent = isDefault
                            ? "\u52d5\u753b\u4e00\u89a7"
                            : "\u691c\u7d22\u7d50\u679c";
                    } else {
                        resultTitleEl.textContent = isDefault
                            ? "\u8a66\u5408\u4e00\u89a7"
                            : "\u691c\u7d22\u7d50\u679c";
                    }
                }

                function setStatsVisibility(state) {
                    if (!statsSectionEl) return;
                    statsSectionEl.hidden = false;
                }

                function updateResultCount(total, page, pageSize, itemCount) {
                    if (!resultCountEl) return;
                    const safePage = Math.max(1, Number(page) || 1);
                    const safeSize = Math.max(1, Number(pageSize) || DEFAULTS.limit);
                    const count = Math.max(0, Number(itemCount) || 0);
                    const totalNum = Number(total);
                    const hasTotal = Number.isFinite(totalNum);
                    if (!hasTotal) {
                        if (!count) {
                            resultCountEl.textContent = "0 / ?";
                            return;
                        }
                        const start = (safePage - 1) * safeSize + 1;
                        const end = start + count - 1;
                        resultCountEl.textContent = `${start}-${end} / ?`;
                        return;
                    }
                    const safeTotal = Math.max(0, totalNum);
                    if (!safeTotal) {
                        resultCountEl.textContent = "0 / 0";
                        return;
                    }
                    const start = Math.min((safePage - 1) * safeSize + 1, safeTotal);
                    const end =
                        count > 0
                            ? Math.min(start + count - 1, safeTotal)
                            : Math.min(safePage * safeSize, safeTotal);
                    resultCountEl.textContent = `${start}-${end} / ${safeTotal}`;
                }

                function renderPagerPages(container, currentPageValue, pageSize, total, hasNext) {
                    if (!container) return;
                    container.innerHTML = "";
                    const pages = [];
                    const addPage = (p) => {
                        if (!pages.includes(p)) pages.push(p);
                    };
                    const totalNum = Number(total);
                    const hasTotal = Number.isFinite(totalNum);
                    const totalPages = hasTotal
                        ? Math.max(1, Math.ceil(totalNum / pageSize))
                        : null;
                    const isMobile =
                        typeof window !== "undefined" &&
                        window.matchMedia &&
                        window.matchMedia("(max-width: 600px)").matches;

                    if (isMobile) {
                        if (totalPages) {
                            addPage(1);
                            addPage(totalPages);
                            for (let p = currentPageValue - 1; p <= currentPageValue + 1; p += 1) {
                                if (p >= 1 && p <= totalPages) addPage(p);
                            }
                        } else {
                            const start = Math.max(1, currentPageValue - 1);
                            const end = currentPageValue + 1;
                            for (let p = start; p <= end; p += 1) addPage(p);
                        }
                        pages.sort((a, b) => a - b);
                        let lastMobile = null;
                        for (const p of pages) {
                            if (lastMobile !== null && p - lastMobile > 1) {
                                const ellipsis = document.createElement("span");
                                ellipsis.className = "pager-ellipsis";
                                ellipsis.textContent = "...";
                                container.appendChild(ellipsis);
                            }
                            const btn = document.createElement("button");
                            btn.type = "button";
                            btn.className = "pager-page";
                            btn.textContent = String(p);
                            if (p === currentPageValue) {
                                btn.classList.add("active");
                                btn.disabled = true;
                            } else {
                                btn.addEventListener("click", () =>
                                    doSearch(p, {
                                        allowEmpty: lastListMode === MODE.VIDEO,
                                        preserveScroll: true,
                                    }),
                                );
                            }
                            container.appendChild(btn);
                            lastMobile = p;
                        }
                        return;
                    }

                    if (hasTotal) {
                        const start = Math.max(1, currentPageValue - 2);
                        const end = Math.min(totalPages, currentPageValue + 2);
                        addPage(1);
                        addPage(totalPages);
                        for (let p = start; p <= end; p += 1) addPage(p);
                    } else {
                        const maxPage = hasNext === false ? currentPageValue : currentPageValue + 2;
                        const start = Math.max(1, currentPageValue - 2);
                        const end = Math.max(start, maxPage);
                        if (currentPageValue > 3) addPage(1);
                        for (let p = start; p <= end; p += 1) addPage(p);
                    }
                    pages.sort((a, b) => a - b);
                    let last = null;
                    for (const p of pages) {
                        if (last !== null && p - last > 1) {
                            const ellipsis = document.createElement("span");
                            ellipsis.className = "pager-ellipsis";
                            ellipsis.textContent = "...";
                            container.appendChild(ellipsis);
                        }
                        const btn = document.createElement("button");
                        btn.type = "button";
                        btn.className = "pager-page";
                        btn.textContent = String(p);
                        if (p === currentPageValue) {
                            btn.classList.add("active");
                            btn.disabled = true;
                        } else {
                            btn.addEventListener("click", () =>
                                doSearch(p, {
                                    allowEmpty: lastListMode === MODE.VIDEO,
                                    preserveScroll: true,
                                }),
                            );
                        }
                        container.appendChild(btn);
                        last = p;
                    }
                }

                function updatePager(page, pageSize, total, hasNext, itemCount) {
                    lastTotal = total;
                    lastPage = page;
                    lastPageSize = pageSize;
                    lastHasNext = hasNext;

                    [prevBtn, prevBtnTop].forEach((btn) => {
                        if (btn) btn.disabled = page <= 1;
                    });
                    if (typeof hasNext === "boolean") {
                        [nextBtn, nextBtnTop].forEach((btn) => {
                            if (btn) btn.disabled = !hasNext;
                        });
                    } else {
                        const totalNum = Number(total);
                        const disabled = Number.isFinite(totalNum)
                            ? page * pageSize >= totalNum
                            : true;
                        [nextBtn, nextBtnTop].forEach((btn) => {
                            if (btn) btn.disabled = disabled;
                        });
                    }
                    updateResultCount(total, page, pageSize, itemCount);
                    renderPagerPages(pagerPagesEl, page, pageSize, total, hasNext);
                    renderPagerPages(pagerPagesTopEl, page, pageSize, total, hasNext);
                }

                function buildState(pageOverride) {
                    const limit = clampInt(lastPageSize || DEFAULTS.limit, 1, 200, DEFAULTS.limit);
                    const page = clampInt(
                        pageOverride || lastPage || DEFAULTS.page,
                        1,
                        100000,
                        DEFAULTS.page,
                    );
                    if (currentMode === MODE.VIDEO) {
                        return {
                            mode: MODE.VIDEO,
                            q: normalizeVideoQuery(videoQueryEl ? videoQueryEl.value : ""),
                            locate_id: locateEl ? locateEl.value : "",
                            limit,
                            page,
                        };
                    }
                    if (currentMode === MODE.CARD) {
                        return {
                            mode: MODE.CARD,
                            p1: readPlayerId(cardPlayer1Input, cardPlayer1IdEl),
                            p2: readPlayerId(cardPlayer2Input, cardPlayer2IdEl),
                            ch1: cardChar1El ? cardChar1El.value : "",
                            ch2: cardChar2El ? cardChar2El.value : "",
                            vid: extractVideoId(cardVideoEl ? cardVideoEl.value : ""),
                            w: getWinnerValue(document.querySelector('[data-winner-group="card"]')),
                            limit,
                            page,
                        };
                    }
                    return {
                        mode: MODE.PLAYER,
                        p: readPlayerId(playerInput, playerIdEl),
                        ch: playerCharEl ? playerCharEl.value : "",
                        vid: extractVideoId(playerVideoEl ? playerVideoEl.value : ""),
                        w: getWinnerValue(document.querySelector('[data-winner-group="player"]')),
                        limit,
                        page,
                    };
                }

                function buildCanonicalQuery(state) {
                    const entries = [];
                    if (state.mode && state.mode !== DEFAULTS.mode) {
                        entries.push(["mode", state.mode]);
                    }
                    if (state.mode === MODE.VIDEO) {
                        if (state.q) entries.push(["q", state.q]);
                        if (state.locate_id) entries.push(["locate_id", state.locate_id]);
                    } else if (state.mode === MODE.CARD) {
                        if (state.p1) entries.push(["p1", state.p1]);
                        if (state.p2) entries.push(["p2", state.p2]);
                        if (state.ch1) entries.push(["ch1", state.ch1]);
                        if (state.ch2) entries.push(["ch2", state.ch2]);
                        if (state.vid) entries.push(["vid", state.vid]);
                        if (state.w && state.w !== "all") entries.push(["w", state.w]);
                    } else {
                        if (state.p) entries.push(["p", state.p]);
                        if (state.ch) entries.push(["ch", state.ch]);
                        if (state.vid) entries.push(["vid", state.vid]);
                        if (state.w && state.w !== "all") entries.push(["w", state.w]);
                    }
                    if (state.limit && state.limit !== DEFAULTS.limit)
                        entries.push(["limit", String(state.limit)]);
                    if (state.page && state.page !== DEFAULTS.page)
                        entries.push(["page", String(state.page)]);
                    return entries
                        .map(
                            ([key, value]) =>
                                `${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`,
                        )
                        .join("&");
                }

                function updateUrl(state) {
                    const query = buildCanonicalQuery(state);
                    const nextUrl = query
                        ? `${window.location.pathname}?${query}`
                        : window.location.pathname;
                    window.history.replaceState(null, "", nextUrl);
                }

                function buildMatchQuery(state) {
                    const params = new URLSearchParams();
                    params.set("mode", state.mode);
                    if (state.mode === MODE.CARD) {
                        if (state.p1) params.set("p1", state.p1);
                        if (state.p2) params.set("p2", state.p2);
                        if (state.ch1) params.set("ch1", state.ch1);
                        if (state.ch2) params.set("ch2", state.ch2);
                    } else {
                        if (state.p) params.set("p", state.p);
                        if (state.ch) params.set("ch", state.ch);
                    }
                    if (state.vid) params.set("vid", state.vid);
                    if (state.w && state.w !== "all") params.set("w", state.w);
                    params.set("sort", "recent");
                    params.set("expand", "names");
                    params.set("limit", String(state.limit));
                    params.set("page", String(state.page));
                    return params.toString();
                }

                function buildVideoQuery(state) {
                    const params = new URLSearchParams();
                    if (state.q) params.set("q", state.q);
                    if (state.locate_id) params.set("locate_id", state.locate_id);
                    params.set("sort", "uploaded_at");
                    params.set("order", "desc");
                    params.set("limit", String(state.limit));
                    params.set("page", String(state.page));
                    return params.toString();
                }

                function formatVideoDate(item) {
                    const displayDate = item.display_uploaded_at || item.displayUploadedAt;
                    if (displayDate) return String(displayDate);
                    const epoch = Number(item.uploaded_at ?? item.uploadedAt);
                    if (!Number.isFinite(epoch) || epoch <= 0) return "";
                    const d = new Date(epoch * 1000);
                    const y = d.getFullYear();
                    const m = String(d.getMonth() + 1).padStart(2, "0");
                    const day = String(d.getDate()).padStart(2, "0");
                    return `${y}-${m}-${day}`;
                }

                function renderVideos(items) {
                    if (!videoBody) return;
                    videoBody.innerHTML = "";
                    lastMatchItems = [];
                    updateSequenceButton();
                    if (!items.length) {
                        const empty = document.createElement("div");
                        empty.className = "empty-state";
                        empty.textContent = "該当する動画がありません。";
                        videoBody.appendChild(empty);
                        return;
                    }
                    for (const item of items) {
                        const videoId = String(item.video_id || "").trim();
                        const title = String(item.title || "").trim() || "-";
                        const channelName = String(item.channel_name || "").trim() || "-";
                        const channelUrl = String(item.channel_url || "").trim();
                        const locateName = String(item.locate_name || "").trim() || "-";
                        const dateText = formatVideoDate(item) || "-";
                        const detailUrl = `video/?vid=${encodeURIComponent(videoId)}`;

                        const card = document.createElement("div");
                        card.className = "video-card is-clickable";
                        card.dataset.href = detailUrl;
                        card.tabIndex = 0;
                        card.addEventListener("click", (event) => {
                            const target = event.target;
                            if (target && target.closest && target.closest("a")) return;
                            window.location.href = detailUrl;
                        });
                        card.addEventListener("keydown", (event) => {
                            if (event.key === "Enter" || event.key === " ") {
                                event.preventDefault();
                                window.location.href = detailUrl;
                            }
                        });

                        const thumb = document.createElement("img");
                        thumb.className = "video-thumb";
                        thumb.loading = "lazy";
                        thumb.decoding = "async";
                        if (videoId) {
                            thumb.src = `https://img.youtube.com/vi/${encodeURIComponent(videoId)}/hqdefault.jpg`;
                            thumb.alt = title || videoId;
                        } else {
                            thumb.classList.add("empty");
                            thumb.alt = "";
                        }

                        const thumbWrap = document.createElement("div");
                        thumbWrap.className = "video-thumb-wrap";
                        if (videoId) {
                            const thumbLink = document.createElement("a");
                            thumbLink.className = "video-link";
                            thumbLink.href = detailUrl;
                            thumbLink.appendChild(thumb);
                            thumbWrap.appendChild(thumbLink);
                        } else {
                            thumbWrap.appendChild(thumb);
                        }

                        const titleEl = document.createElement("div");
                        titleEl.className = "video-title";
                        titleEl.textContent = title;
                        titleEl.title = title;

                        const meta = document.createElement("div");
                        meta.className = "video-meta";

                        const channelRow = document.createElement("div");
                        channelRow.className = "video-meta-item";
                        const channelLabel = document.createElement("span");
                        channelLabel.className = "label";
                        channelLabel.textContent = "チャンネル：";
                        const channelValue = document.createElement("span");
                        channelValue.className = "video-meta-value";
                        if (channelUrl) {
                            const channelLink = document.createElement("a");
                            channelLink.className = "video-meta-link";
                            channelLink.href = channelUrl;
                            channelLink.target = "_blank";
                            channelLink.rel = "noopener";
                            const channelText = document.createElement("span");
                            channelText.textContent = channelName;
                            channelLink.appendChild(channelText);
                            channelValue.appendChild(channelLink);
                        } else {
                            const channelText = document.createElement("span");
                            channelText.textContent = channelName;
                            channelValue.appendChild(channelText);
                        }
                        channelRow.appendChild(channelLabel);
                        channelRow.appendChild(channelValue);

                        const dateRow = document.createElement("div");
                        dateRow.className = "video-meta-item";
                        const dateLabel = document.createElement("span");
                        dateLabel.className = "label";
                        dateLabel.textContent = "投稿日：";
                        const dateValue = document.createElement("span");
                        dateValue.className = "video-meta-value";
                        dateValue.textContent = dateText;
                        dateRow.appendChild(dateLabel);
                        dateRow.appendChild(dateValue);

                        const locateRow = document.createElement("div");
                        locateRow.className = "video-meta-item";
                        const locateLabel = document.createElement("span");
                        locateLabel.className = "label";
                        locateLabel.textContent = "場所：";
                        const locateValue = document.createElement("span");
                        locateValue.className = "video-meta-value";
                        locateValue.textContent = locateName;
                        locateRow.appendChild(locateLabel);
                        locateRow.appendChild(locateValue);

                        meta.appendChild(channelRow);
                        meta.appendChild(dateRow);
                        meta.appendChild(locateRow);

                        card.appendChild(thumbWrap);
                        card.appendChild(titleEl);
                        card.appendChild(meta);
                        videoBody.appendChild(card);
                    }
                }

                function buildSequenceUrl(items) {
                    const params = new URLSearchParams();
                    for (const row of items) {
                        const vid = String(row.videoId || "").trim();
                        if (!vid) continue;
                        const start = Math.max(0, Math.trunc(Number(row.tStart) || 0));
                        const endNum = Number(row.tEnd);
                        const end = Number.isFinite(endNum)
                            ? Math.max(0, Math.trunc(endNum))
                            : "";
                        const p1Name = resolvePlayerName(row.p1Name, row.p1Id);
                        const p2Name = resolvePlayerName(row.p2Name, row.p2Id);
                        const p1Char = String(row.p1Char || row.p1CharId || "").trim();
                        const p2Char = String(row.p2Char || row.p2CharId || "").trim();
                        const left = p1Char ? `${p1Name}(${p1Char})` : p1Name;
                        const right = p2Char ? `${p2Name}(${p2Char})` : p2Name;
                        const label = [left, right].filter(Boolean).join(" vs ");
                        let entry = `${encodeURIComponent(vid)}@${start}${
                            end !== "" ? `:${end}` : ""
                        }`;
                        if (label) entry += `~${encodeURIComponent(label)}`;
                        params.append("item", entry);
                    }
                    const query = params.toString();
                    return query ? `playlist/?${query}` : "";
                }

                function updateSequenceButton() {
                    if (!playSeqBtn) return;
                    const isMatchList = lastListMode !== MODE.VIDEO;
                    const hasItems = lastMatchItems.some((row) => row.videoId);
                    playSeqBtn.hidden = !isMatchList;
                    playSeqBtn.disabled = !hasItems;
                }

                function fmtSec(sec) {
                    const n = Number(sec);
                    if (!Number.isFinite(n)) return "";
                    const s = Math.max(0, Math.trunc(n));
                    const h = Math.floor(s / 3600);
                    const m = Math.floor((s % 3600) / 60);
                    const ss = s % 60;
                    const pad2 = (x) => String(x).padStart(2, "0");
                    if (h > 0) return `${h}:${pad2(m)}:${pad2(ss)}`;
                    return `${m}:${pad2(ss)}`;
                }

                function fmtRange(startSec, endSec) {
                    const start = fmtSec(startSec);
                    const end = fmtSec(endSec);
                    if (start && end) return `${start} - ${end}`;
                    return start || end || "";
                }

                function fmtDuration(startSec, endSec) {
                    const start = Number(startSec);
                    const end = Number(endSec);
                    if (!Number.isFinite(start) || !Number.isFinite(end)) return "";
                    const diff = Math.max(0, Math.trunc(end - start));
                    if (!diff) return "";
                    return fmtSec(diff);
                }

                function ytUrl(videoId, startSec) {
                    const t = Math.max(0, Math.trunc(Number(startSec) || 0));
                    return `https://www.youtube.com/watch?v=${encodeURIComponent(videoId)}&t=${t}s`;
                }

                function buildCharImage(charId, charName) {
                    const cleanId = String(charId || "").trim();
                    const img = document.createElement("img");
                    img.className = "match-char-img";
                    img.decoding = "async";
                    img.loading = "lazy";
                    if (!cleanId) {
                        img.classList.add("empty");
                        img.alt = "";
                        return img;
                    }
                    const portraitPrefix = "match_card";
                    img.src = `${IMAGE_BASE}${portraitPrefix}_${encodeURIComponent(cleanId)}.png`;
                    img.alt = charName ? String(charName) : cleanId;
                    img.addEventListener("error", () => {
                        img.classList.add("empty");
                        img.removeAttribute("src");
                    });
                    return img;
                }

                function resolvePlayerName(name, id) {
                    const raw = String(name || "").trim();
                    if (raw && raw !== "-") return raw;
                    const fallback = String(id || "").trim();
                    return fallback || "-";
                }

                function createTextLink(text, href, className) {
                    const hasLink = Boolean(href);
                    const el = document.createElement(hasLink ? "a" : "div");
                    if (className) el.className = className;
                    if (hasLink) {
                        el.href = href;
                        el.classList.add("match-link");
                    }
                    if (text) {
                        el.textContent = text;
                        el.title = text;
                    }
                    return el;
                }

                function isInteractiveTarget(target) {
                    return Boolean(
                        target && target.closest("a, button, input, select, textarea, label"),
                    );
                }

                function normalizeMatch(it) {
                    const p1 = it.p1 || {};
                    const p2 = it.p2 || {};
                    return {
                        id: it.match_id ?? it.id ?? "",
                        videoId: it.video_id || "",
                        videoTitle: "",
                        videoUploadedAt: "",
                        tStart: it.start_sec ?? "",
                        tEnd: it.end_sec ?? "",
                        p1Id: p1.player_id ?? "",
                        p1Name: p1.player_name || p1.player_raw || "",
                        p1CharId: p1.char_id || "",
                        p1Char: p1.char_name || p1.char_raw || "",
                        p2Id: p2.player_id ?? "",
                        p2Name: p2.player_name || p2.player_raw || "",
                        p2CharId: p2.char_id || "",
                        p2Char: p2.char_name || p2.char_raw || "",
                        winner: it.winner ?? "",
                    };
                }

                function normalizeWinnerSide(raw) {
                    const v = String(raw ?? "")
                        .trim()
                        .toLowerCase();
                    if (v === "p1" || v === "player1" || v === "1" || v === "left") return "p1";
                    if (v === "p2" || v === "player2" || v === "2" || v === "right") return "p2";
                    return "";
                }

                function updateVideoInfoElements() {
                    document.querySelectorAll("[data-video-id]").forEach((el) => {
                        const id = el.getAttribute("data-video-id") || "";
                        if (!id) return;
                        const info = videoInfoCache.get(id);
                        if (info && info.title) {
                            el.textContent = info.title;
                            el.title = info.title;
                        }
                    });
                    document.querySelectorAll("[data-video-date-id]").forEach((el) => {
                        const id = el.getAttribute("data-video-date-id") || "";
                        if (!id) return;
                        const info = videoInfoCache.get(id);
                        if (info && info.date) {
                            el.textContent = `${DATE_PREFIX}${info.date}`;
                            el.title = `${DATE_PREFIX}${info.date}`;
                        }
                    });
                }

                async function fetchVideoInfo(videoId) {
                    const cleanId = String(videoId || "").trim();
                    if (!cleanId) return;
                    if (videoInfoCache.has(cleanId) || videoInfoPending.has(cleanId)) return;
                    videoInfoPending.add(cleanId);
                    try {
                        const url = `${API_BASE}/api/videos?vid=${encodeURIComponent(cleanId)}&limit=5`;
                        const res = await fetch(url);
                        if (!res.ok) return;
                        const data = await res.json();
                        const items = Array.isArray(data.items) ? data.items : [];
                        const exact = items.find((it) => String(it.video_id) === cleanId);
                        const picked = exact || items[0];
                        if (!picked) return;
                        const title = picked.title ? String(picked.title) : "";
                        let dateText = "";
                        const displayDate =
                            picked.display_uploaded_at || picked.displayUploadedAt || "";
                        if (displayDate) {
                            dateText = String(displayDate);
                        } else {
                            const epoch = Number(picked.uploaded_at ?? picked.uploadedAt);
                            if (Number.isFinite(epoch) && epoch > 0) {
                                const d = new Date(epoch * 1000);
                                const y = d.getFullYear();
                                const m = String(d.getMonth() + 1).padStart(2, "0");
                                const day = String(d.getDate()).padStart(2, "0");
                                dateText = `${y}-${m}-${day}`;
                            }
                        }
                        if (title || dateText) {
                            const info = videoInfoCache.get(cleanId) || {};
                            if (title) info.title = title;
                            if (dateText) info.date = dateText;
                            videoInfoCache.set(cleanId, info);
                        }
                    } catch {
                        // ignore
                    } finally {
                        videoInfoPending.delete(cleanId);
                    }
                }

                async function hydrateVideoInfo(videoIds) {
                    const unique = Array.from(new Set(videoIds.filter(Boolean)));
                    if (!unique.length) return;
                    const chunkSize = 20;
                    for (let i = 0; i < unique.length; i += chunkSize) {
                        const chunk = unique.slice(i, i + chunkSize);
                        await Promise.all(chunk.map((id) => fetchVideoInfo(id)));
                    }
                    updateVideoInfoElements();
                }

                function renderMatches(items) {
                    if (typeof window.renderMatchCards !== "function") return;
                    lastMatchItems = items.map((item) => normalizeMatch(item));
                    updateSequenceButton();
                    window.renderMatchCards({
                        container: matchBody,
                        items,
                        emptyText:
                            "\u8a72\u5f53\u3059\u308b\u8a66\u5408\u304c\u3042\u308a\u307e\u305b\u3093\u3002",
                        normalizeMatch,
                        normalizeWinnerSide,
                        ytUrl,
                        fmtRange,
                        fmtSec,
                        fmtDuration,
                        datePrefix: DATE_PREFIX,
                        videoLabel: "\u52d5\u753b",
                        correctionLabel: "\u60c5\u5831\u8a02\u6b63",
                        getCorrectionHref: (row) =>
                            row && row.id ? `correction/?id=${encodeURIComponent(row.id)}` : "",
                        hydrateVideoInfo,
                        isInteractiveTarget,
                        createTextLink,
                        buildCharImage,
                        resolvePlayerName,
                        resolvePlayerLinkId: (display, id) => {
                            const clean = String(id || "").trim();
                            if (!clean || clean === "0") return "";
                            return clean;
                        },
                        resolveCharacterId: (charId) => charId || "",
                        resolveCharacterName: (charId, charName) =>
                            String(charName || charId || ""),
                        getVideoLinkHref: (videoId) => `video/?vid=${encodeURIComponent(videoId)}`,
                        getCharacterLinkHref: (charId) =>
                            `character/?c=${encodeURIComponent(charId)}`,
                        getPlayerLinkHref: (playerId) =>
                            `player/?p=${encodeURIComponent(playerId)}`,
                    });
                }
                async function loadCharacters() {
                    const selects = [playerCharEl, cardChar1El, cardChar2El].filter(Boolean);
                    if (!selects.length) return;
                    try {
                        const url = `${API_BASE}/api/characters?sort=sort_index&order=asc&limit=200`;
                        const res = await fetch(url);
                        if (!res.ok) return;
                        const data = await res.json();
                        const items = Array.isArray(data.items) ? data.items : [];
                        selects.forEach((selectEl) => {
                            const current = selectEl.value;
                            selectEl.innerHTML = "";
                            const optAll = document.createElement("option");
                            optAll.value = "";
                            optAll.textContent = "\u3059\u3079\u3066";
                            selectEl.appendChild(optAll);
                            for (const item of items) {
                                const id = String(item.char_id || "").trim();
                                const name = String(
                                    item.char_disp_name || item.display_name || "",
                                ).trim();
                                if (!id) continue;
                                if (
                                    name === "\u4e0d\u660e" ||
                                    id === "0" ||
                                    id.toLowerCase() === "unknown"
                                ) {
                                    continue;
                                }
                                const opt = document.createElement("option");
                                opt.value = id;
                                opt.textContent = name || id;
                                selectEl.appendChild(opt);
                            }
                            if (current) selectEl.value = current;
                        });
                    } catch {
                        // ignore
                    }
                }

                async function loadLocates() {
                    if (!locateEl) return;
                    try {
                        const url = `${API_BASE}/api/locates`;
                        const res = await fetch(url);
                        if (!res.ok) return;
                        const data = await res.json();
                        const items = Array.isArray(data.items) ? data.items : [];
                        const current = locateEl.value;
                        locateEl.innerHTML = "";
                        const optAll = document.createElement("option");
                        optAll.value = "";
                        optAll.textContent = "\u3059\u3079\u3066";
                        locateEl.appendChild(optAll);
                        for (const item of items) {
                            const id = String(item.locate_id ?? "").trim();
                            const name = String(item.locate_name ?? "").trim();
                            if (!id) continue;
                            const opt = document.createElement("option");
                            opt.value = id;
                            opt.textContent = name || id;
                            locateEl.appendChild(opt);
                        }
                        if (current) locateEl.value = current;
                    } catch {
                        // ignore
                    }
                }

                function closeSuggestions(container) {
                    if (!container) return;
                    container.classList.remove("open");
                    container.innerHTML = "";
                }

                function setupPlayerSuggest(inputEl, hiddenEl, listEl) {
                    if (!inputEl || !listEl) return;
                    let pending = 0;

                    const renderList = (items) => {
                        listEl.innerHTML = "";
                        if (!items.length) {
                            listEl.classList.remove("open");
                            return;
                        }
                        for (const item of items) {
                            const playerId = String(item.player_id ?? "");
                            const display =
                                String(item.display_name || item.canonical_name || "").trim() ||
                                playerId;
                            const row = document.createElement("div");
                            row.className = "suggestion-item";
                            row.textContent = display;
                            row.dataset.id = playerId;
                            row.addEventListener("click", () => {
                                inputEl.value = display;
                                if (hiddenEl) hiddenEl.value = playerId;
                                closeSuggestions(listEl);
                                toggleClearButton(inputEl);
                            });
                            listEl.appendChild(row);
                        }
                        listEl.classList.add("open");
                    };

                    inputEl.addEventListener("input", async () => {
                        const value = String(inputEl.value || "").trim();
                        if (hiddenEl) hiddenEl.value = "";
                        if (!value) {
                            closeSuggestions(listEl);
                            return;
                        }
                        pending += 1;
                        const currentPending = pending;
                        try {
                            if (currentPending !== pending) return;
                            const items = await fetchPlayerSuggestions(value, 20);
                            if (currentPending !== pending) return;
                            const needle = normalizeKana(value);
                            const filtered = items.filter((it) => {
                                const id = String(it.player_id || "").toLowerCase();
                                const canonical = normalizeKana(it.canonical_name || "");
                                const display = normalizeKana(it.display_name || "");
                                return (
                                    id.includes(value.toLowerCase()) ||
                                    canonical.includes(needle) ||
                                    display.includes(needle)
                                );
                            });
                            renderList(filtered);
                        } catch {
                            closeSuggestions(listEl);
                        }
                    });

                    inputEl.addEventListener("blur", () => {
                        setTimeout(() => {
                            if (!listEl.matches(":hover")) closeSuggestions(listEl);
                        }, 120);
                    });

                    document.addEventListener("click", (e) => {
                        if (!inputEl.contains(e.target) && !listEl.contains(e.target)) {
                            closeSuggestions(listEl);
                        }
                    });
                }

                async function applyPlayerIdToInput(inputEl, hiddenEl, id) {
                    if (!inputEl || !id) return;
                    try {
                        const url = `${API_BASE}/api/players?pid=${encodeURIComponent(id)}`;
                        const res = await fetch(url);
                        if (!res.ok) {
                            inputEl.value = id;
                            return;
                        }
                        const data = await res.json();
                        const items = Array.isArray(data.items) ? data.items : [];
                        const exact = items.find((it) => String(it.player_id) === String(id));
                        const picked = exact || items[0];
                        const name = picked
                            ? String(picked.display_name || picked.canonical_name || id)
                            : id;
                        inputEl.value = name;
                        if (hiddenEl) hiddenEl.value = id;
                    } catch {
                        inputEl.value = id;
                    }
                }

                function parseQuery() {
                    const params = new URLSearchParams(window.location.search);
                    const modeRaw = params.get("mode") || DEFAULTS.mode;
                    const mode = Object.values(MODE).includes(modeRaw) ? modeRaw : DEFAULTS.mode;
                    if (mode === MODE.VIDEO) {
                        return {
                            mode,
                            q: (params.get("q") || "").trim(),
                            locate_id: (params.get("locate_id") || "").trim(),
                            limit: clampInt(params.get("limit"), 1, 200, DEFAULTS.limit),
                            page: clampInt(params.get("page"), 1, 100000, DEFAULTS.page),
                        };
                    }
                    if (mode === MODE.CARD) {
                        return {
                            mode,
                            p1: (params.get("p1") || "").trim(),
                            p2: (params.get("p2") || "").trim(),
                            ch1: (params.get("ch1") || "").trim(),
                            ch2: (params.get("ch2") || "").trim(),
                            vid: (params.get("vid") || "").trim(),
                            w: (params.get("w") || "all").trim(),
                            limit: clampInt(params.get("limit"), 1, 200, DEFAULTS.limit),
                            page: clampInt(params.get("page"), 1, 100000, DEFAULTS.page),
                        };
                    }
                    return {
                        mode,
                        p: (params.get("p") || "").trim(),
                        ch: (params.get("ch") || "").trim(),
                        vid: (params.get("vid") || "").trim(),
                        w: (params.get("w") || "all").trim(),
                        limit: clampInt(params.get("limit"), 1, 200, DEFAULTS.limit),
                        page: clampInt(params.get("page"), 1, 100000, DEFAULTS.page),
                    };
                }

                function applyState(state) {
                    if (!state) return;
                    setMode(state.mode);
                    lastPage = clampInt(state.page, 1, 100000, DEFAULTS.page);
                    lastPageSize = clampInt(state.limit, 1, 200, DEFAULTS.limit);

                    const playerWinner = document.querySelector('[data-winner-group="player"]');
                    const cardWinner = document.querySelector('[data-winner-group="card"]');

                    if (state.mode === MODE.VIDEO) {
                        if (videoQueryEl) videoQueryEl.value = state.q || "";
                        if (locateEl) locateEl.value = state.locate_id || "";
                    } else if (state.mode === MODE.CARD) {
                        if (cardPlayer1IdEl) cardPlayer1IdEl.value = state.p1 || "";
                        if (cardPlayer2IdEl) cardPlayer2IdEl.value = state.p2 || "";
                        if (cardChar1El) cardChar1El.value = state.ch1 || "";
                        if (cardChar2El) cardChar2El.value = state.ch2 || "";
                        if (cardVideoEl) cardVideoEl.value = state.vid || "";
                        setWinnerValue(cardWinner, state.w || "all");
                    } else {
                        if (playerIdEl) playerIdEl.value = state.p || "";
                        if (playerCharEl) playerCharEl.value = state.ch || "";
                        if (playerVideoEl) playerVideoEl.value = state.vid || "";
                        setWinnerValue(playerWinner, state.w || "all");
                    }
                    refreshClearButtons();
                }

                function getScrollPreference() {
                    const params = new URLSearchParams(window.location.search);
                    const raw = String(params.get("scroll") || "")
                        .trim()
                        .toLowerCase();
                    const hasQuery = Array.from(params.keys()).some((key) => key !== "scroll");
                    return { raw, hasQuery };
                }

                function applyScrollPreference(pref) {
                    if (!pref) return;
                    const searchTarget = searchPanelEl
                        ? searchPanelEl.closest("section") || searchPanelEl
                        : null;
                    const resultTarget = resultTitleEl
                        ? resultTitleEl.closest("section") || resultTitleEl
                        : null;
                    if (pref.raw === "form") {
                        if (searchTarget) {
                            searchTarget.scrollIntoView({ behavior: "smooth", block: "start" });
                        }
                        return;
                    }
                    if (pref.raw === "results" || (!pref.raw && pref.hasQuery)) {
                        if (resultTarget) {
                            resultTarget.scrollIntoView({ behavior: "smooth", block: "start" });
                        }
                    }
                }

                async function doSearch(pageOverride, options = {}) {
                    const allowEmpty = Boolean(options.allowEmpty);
                    const preserveScroll = Boolean(options.preserveScroll);
                    const scrollToResults = Boolean(options.scrollToResults);
                    const scrollPos = preserveScroll
                        ? { x: window.scrollX || 0, y: window.scrollY || 0 }
                        : null;
                    let unresolved = false;
                    if (currentMode === MODE.PLAYER) {
                        await resolvePlayerIdFromInput(playerInput, playerIdEl);
                        unresolved = hasUnresolvedPlayer(playerInput, playerIdEl);
                    } else if (currentMode === MODE.CARD) {
                        await Promise.all([
                            resolvePlayerIdFromInput(cardPlayer1Input, cardPlayer1IdEl),
                            resolvePlayerIdFromInput(cardPlayer2Input, cardPlayer2IdEl),
                        ]);
                        unresolved =
                            hasUnresolvedPlayer(cardPlayer1Input, cardPlayer1IdEl) ||
                            hasUnresolvedPlayer(cardPlayer2Input, cardPlayer2IdEl);
                    }
                    const state = buildState(pageOverride);
                    const isEmptySearch = state.mode !== MODE.VIDEO && isDefaultState(state);
                    const isEmptyVideoSearch =
                        state.mode === MODE.VIDEO && !state.q && !state.locate_id;

                    searchBtn.disabled = true;
                    setError("");

                    if (isEmptySearch && !allowEmpty) {
                        searchBtn.disabled = false;
                        return;
                    }
                    if (isEmptyVideoSearch && !allowEmpty) {
                        searchBtn.disabled = false;
                        return;
                    }

                    const listMode = getListMode(state);
                    syncResultBodies(listMode);
                    updateResultTitle(state);
                    setStatsVisibility(state);
                    updateUrl(state);

                    try {
                        if (unresolved) {
                            if (listMode === MODE.VIDEO) {
                                renderVideos([]);
                            } else {
                                renderMatches([]);
                            }
                            updatePager(DEFAULTS.page, state.limit, 0, false, 0);
                            return;
                        }
                        if (listMode === MODE.VIDEO) {
                            if (videoBody) {
                                videoBody.innerHTML = "";
                                const loading = document.createElement("div");
                                loading.className = "empty-state";
                                loading.textContent = "読み込み中...";
                                videoBody.appendChild(loading);
                            }
                            const url = `${API_BASE}/api/videos?${buildVideoQuery(state)}`;
                            const res = await fetch(url);
                            const isJson = (res.headers.get("content-type") || "").includes(
                                "application/json",
                            );
                            const payload = isJson ? await res.json() : { items: [] };
                            if (!res.ok) throw new Error(DB_ERROR_MSG);
                            const items = Array.isArray(payload.items) ? payload.items : [];
                            const totalNum = Number(payload.total);
                            const total = Number.isFinite(totalNum) ? totalNum : null;
                            const hasNext =
                                typeof payload.has_next === "boolean" ? payload.has_next : null;
                            const rp = Number(payload.page) || state.page;
                            const rps = Number(payload.limit) || state.limit;
                            renderVideos(items);
                            updatePager(rp, rps, total, hasNext, items.length);
                        } else {
                            if (typeof window.renderLoadingCards === "function") {
                                window.renderLoadingCards(matchBody, "読み込み中...");
                            }
                            const url = `${API_BASE}/api/matches?${buildMatchQuery(state)}`;
                            const res = await fetch(url);
                            const isJson = (res.headers.get("content-type") || "").includes(
                                "application/json",
                            );
                            const payload = isJson ? await res.json() : { items: [] };
                            if (!res.ok) throw new Error(DB_ERROR_MSG);
                            const items = Array.isArray(payload.items) ? payload.items : [];
                            const totalNum = Number(payload.total);
                            const total = Number.isFinite(totalNum) ? totalNum : null;
                            const hasNext =
                                typeof payload.has_next === "boolean" ? payload.has_next : null;
                            const rp = Number(payload.page) || state.page;
                            const rps = Number(payload.limit) || state.limit;
                            renderMatches(items);
                            updatePager(rp, rps, total, hasNext, items.length);
                        }
                    } catch (e) {
                        setError(DB_ERROR_MSG);
                        if (listMode === MODE.VIDEO) {
                            renderVideos([]);
                        } else {
                            renderMatches([]);
                        }
                        updatePager(DEFAULTS.page, state.limit, 0, false, 0);
                    } finally {
                        searchBtn.disabled = false;
                        if (preserveScroll && scrollPos) {
                            requestAnimationFrame(() =>
                                window.scrollTo(scrollPos.x, scrollPos.y),
                            );
                        } else if (scrollToResults) {
                            const resultTarget = resultTitleEl
                                ? resultTitleEl.closest("section") || resultTitleEl
                                : null;
                            if (resultTarget) {
                                const targetTop =
                                    resultTarget.getBoundingClientRect().top + window.scrollY;
                                requestAnimationFrame(() =>
                                    window.scrollTo({
                                        top: Math.max(0, Math.round(targetTop)),
                                        behavior: "smooth",
                                    }),
                                );
                            }
                        }
                    }
                }

                modeButtons.forEach((btn) => {
                    btn.addEventListener("click", () => {
                        const nextMode = btn.dataset.mode;
                        if (currentMode === MODE.PLAYER && nextMode === MODE.CARD) {
                            if (cardPlayer1Input && playerInput) {
                                cardPlayer1Input.value = playerInput.value;
                            }
                            if (cardPlayer1IdEl && playerIdEl) {
                                cardPlayer1IdEl.value = playerIdEl.value;
                            }
                            if (cardChar1El && playerCharEl) {
                                cardChar1El.value = playerCharEl.value;
                            }
                            refreshClearButtons();
                        }
                        setMode(nextMode);
                        const state = buildState(DEFAULTS.page);
                        setError("");
                        setStatsVisibility(state);
                    });
                });

                let resizeTimer = null;
                window.addEventListener("resize", () => {
                    if (resizeTimer) window.clearTimeout(resizeTimer);
                    resizeTimer = window.setTimeout(syncLabelColumns, 120);
                });

                document.querySelectorAll("[data-winner-group]").forEach((container) => {
                    container.addEventListener("click", (e) => {
                        const target = e.target.closest(".winner-option");
                        if (!target) return;
                        setWinnerValue(container, target.dataset.w);
                    });
                });

                searchBtn.addEventListener("click", () =>
                    doSearch(DEFAULTS.page, { scrollToResults: true }),
                );
                prevBtn.addEventListener("click", () =>
                    doSearch(Math.max(1, lastPage - 1), {
                        allowEmpty: lastListMode === MODE.VIDEO,
                        preserveScroll: true,
                    }),
                );
                nextBtn.addEventListener("click", () =>
                    doSearch(lastPage + 1, {
                        allowEmpty: lastListMode === MODE.VIDEO,
                        preserveScroll: true,
                    }),
                );
                if (prevBtnTop) {
                    prevBtnTop.addEventListener("click", () =>
                        doSearch(Math.max(1, lastPage - 1), {
                            allowEmpty: lastListMode === MODE.VIDEO,
                            preserveScroll: true,
                        }),
                    );
                }
                if (nextBtnTop) {
                    nextBtnTop.addEventListener("click", () =>
                        doSearch(lastPage + 1, {
                            allowEmpty: lastListMode === MODE.VIDEO,
                            preserveScroll: true,
                        }),
                    );
                }
                if (playSeqBtn) {
                    playSeqBtn.addEventListener("click", () => {
                        const url = buildSequenceUrl(lastMatchItems);
                        if (!url) return;
                        window.open(url, "_blank", "noopener");
                    });
                }

                shareBtn.addEventListener("click", async () => {
                    setError("");
                    const state = buildState();
                    const query = buildCanonicalQuery(state);
                    const url = new URL(
                        query ? `${window.location.pathname}?${query}` : window.location.pathname,
                        window.location.origin,
                    ).toString();
                    updateUrl(state);
                    try {
                        await navigator.clipboard.writeText(url);
                    } catch (e) {
                        window.prompt("\u5171\u6709URL", url);
                    }
                });

                attachClearButton(playerInput, () => {
                    if (playerIdEl) playerIdEl.value = "";
                });
                attachClearButton(cardPlayer1Input, () => {
                    if (cardPlayer1IdEl) cardPlayer1IdEl.value = "";
                });
                attachClearButton(cardPlayer2Input, () => {
                    if (cardPlayer2IdEl) cardPlayer2IdEl.value = "";
                });
                attachClearButton(playerVideoEl);
                attachClearButton(cardVideoEl);
                attachClearButton(videoQueryEl);

                if (videoQueryEl) {
                    videoQueryEl.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") {
                            e.preventDefault();
                            doSearch(DEFAULTS.page);
                        }
                    });
                }
                [
                    playerInput,
                    cardPlayer1Input,
                    cardPlayer2Input,
                    playerVideoEl,
                    cardVideoEl,
                ].forEach((input) => {
                    if (!input) return;
                    input.addEventListener("keydown", (e) => {
                        if (e.key === "Enter") {
                            e.preventDefault();
                            doSearch(DEFAULTS.page);
                        }
                    });
                });
                if (locateEl) {
                    locateEl.addEventListener("change", () => doSearch(DEFAULTS.page));
                }

                setupPlayerSuggest(playerInput, playerIdEl, playerSuggestions);
                setupPlayerSuggest(cardPlayer1Input, cardPlayer1IdEl, cardPlayer1Suggestions);
                setupPlayerSuggest(cardPlayer2Input, cardPlayer2IdEl, cardPlayer2Suggestions);

                const init = async () => {
                    const state = parseQuery();
                    const scrollPref = getScrollPreference();
                    await Promise.all([loadCharacters(), loadLocates()]);
                    applyState(state);
                    if (state.p) {
                        await applyPlayerIdToInput(playerInput, playerIdEl, state.p);
                    }
                    if (state.p1) {
                        await applyPlayerIdToInput(cardPlayer1Input, cardPlayer1IdEl, state.p1);
                    }
                    if (state.p2) {
                        await applyPlayerIdToInput(cardPlayer2Input, cardPlayer2IdEl, state.p2);
                    }
                    refreshClearButtons();
                    updateResultTitle(state);
                    setStatsVisibility(state);
                    updatePager(DEFAULTS.page, state.limit || DEFAULTS.limit, 0, false, 0);
                    await doSearch(state.page, { allowEmpty: true });
                    applyScrollPreference(scrollPref);
                };

                init();
            </script>
        </main>

        <div class="footer">
            ご意見・ご要望などありましたら、<a
                href="https://twitter.com/tiki_tiki_bone"
                target="_blank"
                >@tiki_tiki_bone</a
            >
            までお知らせください。
        </div>
    </body>
</html>




